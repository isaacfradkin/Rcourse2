---
title: "Lesson 03: Vectors and Basic Functions"
author: "Copyright 2024 Psychology Department. Hebrew University of Jerusalem. All rights reserved"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: false
description: >
  <div style='direction: rtl;'>
  בשיעור זה נלמד סוג מסוים של משתנים, הוקטורים (משתנים המכילים יותר מערך אחד). נלמד גם על פונקציות בסיסיות של שפת התכנות שמאפשרות לבצע חישובים על וקטורים בקלות.
  </div>
runtime: shiny_prerendered
---

<style>
h1, h2, h3, h4, h5, h6 {
  direction: rtl;
}
p {
  direction: rtl;
}
</style>


<!-- tutorial options and checking options - TODO set params -->
```{r setup, include=FALSE}
library(learnr)
library(gradethis)
library(dplyr)

##### פונקציה לבדיקה
exercises_df <- data.frame(
  exercises = c("vec_op_ex1", "vec_op_ex2", "vector_fun_question", "deafult_question", "descrip_question", "arg_question", "vec_op_question", "vec_type_question", "def_vec_ex",
    "vec_basic_question", "index_ex1", "index_ex2", 
    "ed_vec_ex", "mean_ex", "text_fun_ex",
   "text_fun_q",  "final_ex_1", "final_ex_2", "final_ex_3"
  ),
  hebrew = c(
    "תרגיל פעולות על וקטור 1",
    "תרגיל פעולות על וקטור 2",
    "שאלת פונקציות על וקטורים",
    "שאלת ברירת המחדל",
    "שאלת תיאור פונקציה", 
    " שאלת ארגומנטים", 
    "שאלת פעולות על וקטורים",
    "שאלה סוגי וקטורים", 
    "תרגיל הגדרת וקטור חדש", 
    "שאלה השוואת וקטורים", 
    "תרגיל אינדקס 1", 
    "תרגיל אינדקס 2", 
    "עריכת וקטורים", 
    "חישוב ממוצע תרגיל", 
    "תרגיל פונקיציות טקסט", 
    "שאלה טקסט 1", 
    "תרגיל מסכם 1",
    "תרגיל מסכם 2", 
    "תרגיל מסכם 3"

  )
)


check_hash_code   = function(hash){
    exercises = exercises_df$exercises
    response_table = learnrhash::decode_obj(hash)
    if (length(response_table)==0){return("Invalid hash code")}
    correct = response_table %>% filter(label %in% exercises, correct) %>% pull(label)
    incorrect = setdiff(exercises, correct)
    if (length(incorrect) == 0){return("Great work! Hash code is valid")}
    else{
      hebrew = exercises_df  %>% filter(exercises %in% incorrect) %>%pull(hebrew)
      print("The following exercises are missing or incorrect:")
      print(hebrew)
    }

} 


knitr::opts_chunk$set(error = TRUE)
gradethis::gradethis_setup()
```

## וקטורים
בלומדה הקודמת למדנו להכיר משתנים. למדנו שלמשתנים שני מאפיינים מרכזיים, שם וערך. בלומדה הקודמת כל המשתנים שלמדנו להכיר הכילו ערך אחד, שהיה יכול להיות מספר, טקסט או ערך לוגי. היום ניקח את המשתנים לשלב הבא ונלמד להכיר גם משתנים המכילים יותר מערך אחד - וקטורים.  

וקטורים הם מבני נתונים בעלי מימד אחד, אפשר לדמות אותם לשורה אחת, שמכילה מספר ערכים שונים. וקטורים הם מבני הנתונים הפשוטים ביותר בR שיכולים להכיל יותר מערך אחד. 
למשל אם נרצה לשמור את ציוניהם של כל המשתתפים בקורס (כלומר ערך אחד עבור כל תלמיד) זה יכול להיות מאוד מסורבל ליצור משתנה חדש עבור כל תלמידה. יהיה הרבה יותר נוח אם נוכל לשמור את ציוני כל הכיתה יחד בוקטור אחד.

כדי להגדיר וקטור בשפת התכנות של R נשתמש בפקודה `()c`.   
כך שהאות c מסמלת את הפקודה ליצירת וקטור ובתוך הסוגריים נפרט את כל הערכים שהוקטור יכיל. כדי להפריד בין הערכים נשתמש בפסיקים.  
 
לדוגמה:

```{r}
# דוגמה להגדרת וקטור
c(1, 2, 3, 4)

# וקטור של מספרים עוקבים ניתן להגדיר גם כך:
c(1:4)

# גם וקטורים ניתן להגדיר כמשתנים
vector_1 <- c(1, 2, 3, 4)
# אם נרצה להציגו
vector_1

# וקטורים יכולים גם להכיל מחרוזות
string_vector <- c("a", "b", "c", "d")
string_vector

# או ערכים לוגיים
logical_vector <- c(TRUE, FALSE, TRUE)
logical_vector

```


וקטורים יכולים להכיל את כל סוגי המשתנים שהכרנו (מספרים, מחרוזות וערכים לוגיים) אבל `כל וקטור יכול להכיל רק ערכים מסוג אחד`. אם נשלב בין הסוגים כל האיברים יומרו אוטומטית.  
אתם בוודאי שואלים את עצמכם איך הם יומרו?  
 הלמידה הטובה ביותר נעשית תוך כדי ניסוי וטעיה, אז בררו בעצמכם.  
 בתיבת הקוד למטה נתון לכם וקטור המכיל מספרים בלבד. תוכלו להיעזר בתיבת הקוד כדי לענות על השאלה מטה.  
 החליפו את אחד הערכים בוקטור לערך לוגי, הריצו וראו מה קורה לערכים בוקטור.  לאחר מכן ערכו את הוקטור כך שיכיל רק מחרוזות וערכים לוגיים. הריצו ובדקו מה קרה לערכים. לבסוף בדקו מה קורה לערכים כשמשלבים בוקטור מחרוזת ומספרים.  
 אתם כמובן מוזמנים לערוך כל בדיקה כמה פעמים ובאיזה סדר שנראה לכם. וכמובן שלהשתמש בכל ערך מכל קטגוריה.  

```{r vec_type_ex, exercise=TRUE, exercise.eval = FALSE}
vector_1 <- c(1, 2, 3, 4)
  
```


להן מספר היגדים:  
א. אם נכניס לוקטור מספרים וערכים לוגיים התוצאה תהיה וקטור מספרי  
ב. אם נכניס לוקטור מספרים וערכים לוגיים התוצאה תהיה וקטור של מחרוזות  
ג. אם נכניס לוקטור מחרוזות וערכים לוגיים התוצאה תהיה וקטור לוגי  
ד. אם נכניס לוקטור מחרוזות וערכים לוגיים התוצאה תהיה וקטור של מחרוזות  
ה. אם נכניס לוקטורים מחרוזות ומספרים נקבל וקטור של מחרוזות  
ו. אם נכניס לוקטורים מחרוזות ומספרים נקבל וקטור מספרי

```{r vec_type_question, echo = FALSE}
question("איזה היגדים נכונים?",
         answer("א + ג + ה",  message ="זאת אינה התשובה. בדקו שוב את היגד  ג בקוד."),
         answer("ב + ד + ו", message = "זאת לא התשובה. בדקו את היגד ב וו בקוד"),
         answer("א + ד + ה", correct =TRUE, message = "כל הכבוד!"),
         answer("ב + ג + ו ",message = "כל ההיגדים שבחרתם לא נכונים. בדקו את ההיגדים באמצעות הקוד שנית"),
         allow_retry = TRUE
)
```

###
עכשיו שהבנו מה קורה לערכים בוקטור, נחזור לאופני ההגדרה.
ניתן גם להגדיר כמה משתנים בודדים ואז לאסוף אותם בוקטור
```{r}
# למשל
a = 1
b = 2
c = 3
d = 4
vector_2 <- c(a, b, c, d)
vector_2
```

`שימו לב`  

לאחר שהגדרנו את הוקטור השני, שמורכב מ4 משתנים שונים, הוא מכיל רק את הערכים ושינוי של המשתנים המקוריים לאחר הגדרת הוקטור לא יוביל אוטומטית לשינוי של הוקטור. ראו לדוגמה:

```{r}
# נדפיס את הוקטור
vector_2
# ואת a
a
# נערוך את הערך של a
a = 100
# נבדוק שהוא אכן השתנה
a
# ומה קרה לוקטור
vector_2
# כלום....
# כדי שגם הוקטור ישתנה, נצטרך להגדירו מחדש
vector_2 <- c(a, b, c, d)
vector_2

# לסיום נחזיר את a
# לערכו המקורי
a = 1
# וגם את הוקטור
vector_2 <- c(a, b, c, d)

```

משוכנעים שאיסוף של המשתנים לוקטור אחד זהה להגדרתו באמצעות מספרים? אם לא בואו נשווה בין שני הוקטורים שהגדרנו עד כה.
```{r}
# האם התוצאה באמת זהה?
vector_1 <- c(1, 2, 3, 4)
# בואו נשתמש בהשוואה 
vector_1 == vector_2

```

מה קרה כשביצענו השוואה בין שני וקטורים?  
קיבלנו וקטור חדש, הוקטור החדש באותו אורך כמו השניים המקוריים ומכיל בתוכו את התוצאה של השוואה בין כל זוג ערכים.  למשל אם הערך הראשון בוקטור 1 שווה לערך הראשון בוקטור 2 נקבל TRUE במקום הראשון של התוצאה.  
כלומר, התוצאה היא בעצם וקטור לוגי. 


```{r vec_basic_question, echo = FALSE}
question(" מה לדעתכם הייתה התוצאה עבור ההשוואה הבאה:  
           vector_3 <- c(b, b, c, d)  
         vector_1 == vector_3",
         answer("התוכנה הייתה מחזירה שגיאה",  message ="לא הייתה אמורה להתקבל שגיאה במקרה זה. רק במקרה שהינו מוסיפים עוד איבר לוקטור החדש, ההשוואה בין 5 ל4 ערכים לא הייתה מתאפשרת והיינו מקבלים שגיאה. "),
         answer("FALSE", message = "האמנם הוקטורים כבר לא זהים אבל שימו לב שהתוכנה תחזיר תשובה בנפרד לכל ערך בוקטור."),
         answer("[TRUE, FALSE, TRUE, TRUE]", message = "קרוב מאוד! אבל שימו לב לסדר, הערך הראשון הוא שהשתנה ולא השני. "),
         answer("[FALSE, TRUE, TRUE, TRUE]",correct =TRUE, message = "כיוון ששינינו את הערכך הראשון הוא כבר לא יהיה זהה ולכן האיבר הראשון בתוצאה ישתנה. שאר האיברים לא השתנו ולכן ישארו כמו בדוגמה"),
         allow_retry = TRUE
)
```


### שימוש בנתונים
כעת נחזור לדוגמה שלנו מהשיעור הקודם על שאלון האישיות. כעת נוכל לעבוד עם נתונים שנמדדו מיותר ממשתתף אחד, כמו שלרוב נרצה לעשות במחקר.
קבוצת חברים מסוימת ענתה על השאלון שלנו, להלן סידור של נתוניהם בוקטורים:

```{r}
# וקטור השמות של המשתתפים - שימו לב! וקטור יכול להכיל גם מחרוזות ולא רק מספרים
c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")

# שימו לב, כדי שנשמור את הנתונים עלינו להגדיר משתנה
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")

# עכשיו נראה גם מידע על ציונהם של הקבוצה בתכונה מצפוניות
# הוקטור מטה מכיל את הציון הממוצע של כל משתתף בתכונה זו
ave_C <- c(6, 4, 2, 3, 7, 1)
```

`תרגיל`  
הגדירו וקטור המכיל את ציוני הקבוצה בתכונה של "מוחצנות". 
הגדירו את שם הוקטור כ  ave_E ובו ערך בודד עבור כל משתתף. צרו את המשתנה כך שכל משתתף קיבל ציון של 3 בתכונה זו.

```{r def_vec_ex, exercise=TRUE, exercise.eval = FALSE,exercise.reveal_solution=FALSE}

  
```

```{r def_vec_ex-solution}

ave_E <- c(3, 3, 3, 3, 3, 3)

```

```{r def_vec_ex-check}

grade_this({if (identical(.result,c(3, 3, 3, 3, 3, 3))) {pass("כל הכבוד! ")
}
  fail("עוד לא הגעתם לתוצאה הנכונה. בדקו את שם המשתנה ואת כמות הערכים שהייתם אמורים להכניס")
})

```

### פעולות פשוטות על וקטורים
כמו שניתן לבצע פעולות השוואה עם וקטורים, ניתן גם להשתמש בכל פעולה אחרת שהכרנו עד כה. אבל חשוב להבין איך הפעולות מתבצעות במעבר לעבודה עם וקטורים.   

אם נבצע השוואות ופעולות בין שני וקטורים בעלי אורך זהה הפעולה תקרה בין כל צמד ערכים `או` אם נבצע פעולה בין ערך בודד לוקטור הפעולה תקרה בין כל ערך בוקטור לערך הבודד.  

מה יקרה אם נשווה בין וקטורים בעלי אורכים שונים? למעשה ניתן לבצע פעולות גם בין וקטורים שאינם באותו האורך, כל עוד אחד הוקטורים הוא באורך שהוא פי 2, 3, 4 או כל מספר שלם אחר של הוקטור השני.  
למשל, אם נשווה בין וקטור בעל 6 ערכים לוקטור בעל 5 ערכים נקבל שגיאה. אבל אם נשווה בין וקטור בעל 6 איברים לקטור בעל כמות איברים שמתחלקת ב6 (למשל 12) או כמות איברים ש6 מתחלק בה (למשל 3 או 2) התוכנה תכפיל את הוקטור הקצר יותר ותבצע השוואה.

`שימו לב`  
האמנם ביצוע פעולות בין וקטורים באורכים שונים אפשרי בR , אבל ההשוואה (או כל פעולה אחרת) בין וקטורים שאינם באותו האורך מאוד מבלבלת ולא אינטואטיבית. לכן אנחנו כמעט ולא נשתשמש באופציה זאת מכאן והלאה. לרוב נבצע פעולות בין וקטורים באותו האורך או בין וקטור וערך יחיד.  

עכשיו בואו נראה דוגמאות לפעולות עם וקטורים:  
```{r}
# חיבור
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

# אפשר לחבר וקטורים באותו האורך
ave_C + ave_E

# אפשר גם לכפול בינהם
ave_C * ave_E

# אפשר גם לחלק ולהחסיר ועוד

# עכשיו ננסה להחסיר ערך בודד מכל הערכים בוקטור
ave_C-1 

# או להעלות את הוקטור בחזקת 3
ave_C ^3

# למען הדוגמה נשווה וקטורים באורכים שונים
# ננסה להשוות לוקטור חדש עם 3 איברים
v = c(1, 2, 3)
ave_E == v
# בדוגמה זאת הוקטור של ציוני המוחצנות השווה לוקטור החדש פעמיים

# ועכשיו לוקטור עם 5 איברים
v = c(1,2,3,4,5)
ave_E * v

```

שימו לב כי בדוגמה האחרונה קיבלנו תוצאה, אך גם קיבלנו אזהרה שהוקטורים לא באורכים מתאימים. אין הרבה סיבות בגללן נרצה לבצע השוואה בין וקטור של 6 ערכים לוקטור של 5 ערכים. ולכן אם אתם רואים את האזהרה הזאת שוב, כנראה שיש טעות ואחד הוקטורים לא באורך הנכון.  

נתון לכם הקוד הבא:  
ave_E <- c(3,3,3,3, 3,3)  
ave_E-c(1, 2)  

```{r vec_op_question, echo = FALSE}
question("מה יקרה אם ננסה להריץ את שורת הקוד למעלה?",
         answer("התוכנה הייתה מחזירה שגיאה",  message =" כאשר משווים שני וקטורים בעלי אורכים שונים יש סכנה שנקבל שגיאה, אבל במקרה הזה האורך של הוקטור המקורי מתחלק ב2"),
         answer("FALSE", message = "שורת הקוד מבצעת חיסור ולא השוואה, גם אם הייתה מתבצעת השוואה היינו מקבלים ערך אחד עבור כל איבר בוקטור הארוך יותר"),
         answer("[FALSE, FALSE, FALSE, FALSE, FALSE, FALSE]", message = "קרוב מאוד! אבל שימו לב ששורת הקוד לא מבצעת השוואה אלא חיסור."),
         answer("2 1 2 1 2 1",correct =TRUE, message = "נכון, התוכנה תשכפל את הוקטור הקצר 3 פעמים ותבצע חיסור כאילו מדובר בוקטורים עם אותו אורך"),
         allow_retry = TRUE
)
```

`תרגיל`  
בתיבת הקוד למטה נתונים לכם ציוני הקבוצה בתכונה מצפוניות (C) ובתכונה פתיחות לחוויה (O). צרו וקטור חדש המכיל את היחס בין C לO (כלומר, וקטור חדש בעל תצפית לכל משתתף המכיל את תוצאות החלוקה של ציוני C בO)

```{r vec_op_ex1, exercise=TRUE, exercise.eval = FALSE,exercise.reveal_solution=FALSE}
# נתונים
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_O <- c(2, 3, 6, 3, 1, 7)

# צרו וקטור חדש כאן

```

```{r vec_op_ex1-solution}
# נתונים
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_O <- c(2, 3, 6, 3, 1, 7)

# צרו וקטור חדש כאן
C_O <- ave_C/ave_O


```

```{r vec_op_ex1-check}

grade_this({if (identical(.result, c(6, 4, 2, 3, 7, 1)/c(2, 3, 6, 3, 1, 7))) {pass("מעולה!ביצעתם חלוקה של שני וקטורים")
}
  fail("עוד לא הצלחתם, שימו לב לכיוון של החלוקה. יש לחלק את מצפוניות בפתיחות לחוויה.")
})

```


עכשיו נבצע פעולה שנקראת תקנון של הנתונים. תקנון מתבצע על ידי החסרה של הממוצע וחלוקה בסטיית התקן (של כל הדגימה) של כל תצפית. כך שלאחר המניפולציה נוכל לקבל ציונים מתוקננים אשר יתנו לנו מושג טוב לגבי היחס בין התצפיות הבודדות להתפלגות. 

בתיבה מטה יש לכם את כל הנתונים הדרושים. נתון לכם משתנה אשר מכיל את הממוצע של הקבוצה (mean) ואת סטיית התקן שלה (sd).  
כדי לחשב את ציון המתוקנן של כל משתתף יש להחסיר ממנו את הממוצע ולחלק בסטיית התקן. תוכלו לעשות זאת על הוקטור כולו בשורת קוד אחת.  
צרו וקטור חדש שנקרא Norm_C ומכיל את תוצאותיהם המתוקננות של החברים.  


```{r vec_op_ex2, exercise=TRUE, exercise.eval = FALSE}
# נתונים
ave_C <- c(6, 4, 2, 3, 7, 1)
# ממוצע כל המשתתפים במדגם
mean <- 3.5
# סטיית התקן של כל המשתתפים במדגם
sd <- 0.8

# צרו וקטור חדש כאן

```

```{r vec_op_ex2-solution}
# נתונים
ave_C <- c(6, 4, 2, 3, 7, 1)
# ממוצע כל המשתתפים במדגם
mean <- 3.5
# סטיית התקן של כל המשתתפים במדגם
sd <- 0.8

# צרו וקטור חדש כאן
Norm_C <- (ave_C - mean)/sd

```

```{r vec_op_ex2-check}

grade_this({if(identical(.result,(c(6, 4, 2, 3, 7, 1)-3.5)/0.8)) {pass("כל הכבוד יש לנו וקטור מתוקנן!")
}
  fail("התשובה לא נכונה. האם שמתם לב לסוגריים?")
})

```

## אינדקסים
כעת, כשביצענו מעבר למשתנה רב ערכים (הוקטור) אנחנו נצטרך להשתמש באינדקסים כדי לגשת לערכים בודדים שנמצאים בתוך הוקטור. האינדקס של ערך מסוים הוא בעצם המיקום שלו בתוך הוקטור.  
בשפת התכנות R כל ערך בוקטור מקבל אינדקס, כאשר הערך הראשון בתוך הוקטור הוא באינדקס 1 (שימו לב, אולי זה נראה לכם מאוד אינטואטיבי שמתחילים לספור ב1, אבל אם אתם מכירים שפות תכנות אחרות אולי אתם רגילים ש-0 הוא האינדקס הראשון אז חשוב לקחת בחשבון את השינוי). האינדקס האחרון הוא תמיד מספר האיברים שקיימים בוקטור.  

נוכל לגשת ולערוך ערכים בוקטור מסוים לפי האינדקסים.  

בנוסף לכך האינדקסים יכולים לעזור לנו להשתמש בוקטורים שונים יחד. כמו בדוגמה הראשונה שלנו, ראינו שיש וקטור אחד עם שמות המשתתפים ווקטור אחר עם דירוגיהם בשאלון. 

כעת נלמד איך לגשת לערכים שונים באמצעות אינדקס.

כדי לגשת לאינדקס מסוים נשתמש בסוגריים מרובעים - `[]`  
כאשר נצמיד את הסוגריים המרובעים לשם הוקטור יודפס לנו האינדקס שנמצא בתוך הסוגריים כך:  
vector_name[index]

באמצעות התבנית הזאת ננסה לשלוף את הנתונים של המשתתף השלישי במחקר:
```{r}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

names[3]
ave_C[3]
ave_E[3]
```

מצויין, קיבלנו את הערכים של ג'ואי  

עכשיו נלמד גם איך לשלוף כמה ערכים לפי אינדקס.

```{r}
# אם מעוניינים בטווח של ערכים רציפים ניתן גם להשתמש באפשרות זאת:
ave_C[1:3]

# אם אנחנו רוצים דווקא ערכים לא רציפים אפשר להגדיר וקטור נפרד עם הערכים שרצויים לנו:
ave_C[c(1,5)]

# אפשר גם להשתמש בוקטור לוגי שיסמן מה הערכים הרצויים
# הוקטור הלוגי חייב להיות כמובן באותו אורך
ave_C[c(TRUE, FALSE, FALSE, FALSE, TRUE, FALSE)]

# אפשר גם לשלוף את האינדקסים באמצעות משתנה
ind <- c(1,3,6)
ave_C[ind]


```
  
אבל מה נעשה אם יבקשו מאיתנו לוודא מה התוצאות של רוס? כרגע קל לנו לראות שהוא ראשון ברשימה, אבל אם היו 1000 משתתפים כבר היינו צריכים לפנות לאסטרטגיה אחרת.   
נוכל פשוט לפנות להשוואה בין וקטורים  

`שימו לב`  
בחלק זה נתחיל לקשר בין וקטורים שונים המכילים סוגים שונים של מידע. הקשר בין הוקטורים הינו קשר שאנחנו יצרנו בעת הגדרת הוקטורים, כלומר, כשיצרנו את הנתונים הקפדנו שאם השם של רוס מופיע ראשון ברשימת השמות אז גם הציון שלו בכל תכונה יופיע ראשון בכל שאר הוקטורים. מבחינת התוכנה אין קשר בין הוקטורים ואם ניצור וקטור חדש בו לא הייתה הקפדה על סדר התצפיות לא נוכל לקשר אותו לשאר הנתונים.  

```{r}
# הנתונים שלנו
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_E <- c(3, 3, 3, 3, 3, 3)

# נשווה את וקטור השמות לשם הרצוי
names=="Ross"

# עכשיו יש לנו וקטור שמסמן לנו איפה בוקטור השמות מתקיים התנאי. 
# אפשר להשתמש בוקטור הזה כאינדקס כך:
ave_C[names=="Ross"]
ave_E[names=="Ross"]

```

שימו לב, שהערכים שבהם התנאי מתקיים וקיבלו את הערך TRUE בוקטור של תוצאת ההשוואה הודפסו.

  
`תרגיל`  
בנוסף לנתונים הקודמים נתון לכם וקטור חדש אשר מציין את המגדר של כל משתתף במחקר.
קודם כל הציגו את תוצאותיהן של כל הנשים בתכונה C.  
כדי להציג את תוצאות הנשים צרו וקטור לוגי אשר בודק באיזה אינדקסים בוקטור המגדר נמצאות הנשים. לאחר מכן הדפיסו את האינדקסים הללו מתוך הוקטור המכיל את תשובות הקבוצה לשאלון.  

```{r index_ex1, exercise=TRUE, exercise.eval = FALSE}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
# M = Male, F = Female
gender <- c("M", "M", "M", "F", "F", "F")
ave_C <- c(6, 4, 2, 3, 7, 1)

# הציגו את תוצאות הנשים כאן:


```

```{r index_ex1-solution}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
# M = Male, F = Female
gender <- c("M", "M", "M", "F", "F", "F")
ave_C <- c(6, 4, 2, 3, 7, 1)
# הציגו את תוצאות הנשים כאן:
ave_C[gender=="F"]

```

```{r index_ex1-check}

grade_this({if(identical(.result, c(3, 7, 1))) {pass("מעולה! הדפסתם בהצלחה את ציוני המצפוניות של הנשים בחבורה")
}
  fail("ההדפסה שלכם עוד לא נכונה. בדקו שביצעת את ההשוואה הנכונה וכי המגדר הוא מחרוזת ולכן יש לעשות שימוש בגרשיים")
})

```

עכשיו צרו וקטור חדש שנקרא above_3 אשר יכיל את השמות של כל המשתתפים שערך המצפוניות שלהם (C) גדול מ3.  

```{r index_ex2, exercise=TRUE, exercise.eval = FALSE,exercise.reveal_solution=FALSE}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
# M = Male, F = Female
gender <- c("M", "M", "M", "F", "F", "F")
ave_C <- c(6, 4, 2, 3, 7, 1)

# צרו משנתנה המכיל את השמות שקיבלו ערך מעל 3 כאן:

```

```{r index_ex2-solution}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
# M = Male, F = Female
gender <- c("M", "M", "M", "F", "F", "F")
ave_C <- c(6, 4, 2, 3, 7, 1)

#  ערך מעל 3 כאן:
above_3 <- names[ave_C>3]

```

```{r index_ex2-check}

grade_this({if (identical(.result, c("Ross", "Chandler", "Monica"))) 
  {pass("קוד שכבתבת מדויק! חשוב לשים לב לתשובת שקיבלת כאן, התוצאה היא בעצם וקטור נוסף וכמות האיברים בו היא כמות האיברים עבורם תוצאת ההשוואה יצאה חיובית")
}
  fail("עוד לא הגעתם לתוצאה הנכונה, לבדוק את התנאים שהכנסת את ההשוואה הנכונה")
})


```


### עריכת וקטורים
אנחנו יכולים לעשות יותר מלהדפיס אינדקסים מתוך הוקטור. אנחנו יכולים גם לגשת לאינדקסים ספציפיים ולשנות את ערכם.     
גם לכם הוקטור של התכונה E נראה מוזר? מי שמכיר את החברים בוודאי יודע שלא לכולם יש רמת מוחצנות זהה.   
בואו נשנה את רמת המוחצנות של ג'ואי ל6.
```{r}
ave_E <- c(3, 3, 3, 3, 3, 3)
# לפי סדר בו הגדרנו את הוקטור נרצה לשנות את הערך השלישי
ave_E[3] <- 6
# בואו נראה מה יצא
ave_E

```
בעצם יש לנו דרך טובה יותר לשנות ערכים!

`תרגיל`  
עכשיו שנו אתם את שאר הערכים שאינם נכונים.  
שנו את הערך של פיבי ל5 
ולאחר מכן את הערך של רוס וצ'נדלר ל1.     
השתמשו בשמות המשתתפים לשם כך על ידי יצירת וקטור לוגי עם התנאי המתאים (ולא באינדקסים המספריים שלהם).  
לסיום הדפיסו את הוקטור המתוקן.

```{r ed_vec_ex, exercise=TRUE, exercise.eval = FALSE}

names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_E <- c(3, 3, 6, 3, 3, 3)
# ערכו את הוקטור כאן:



```

```{r ed_vec_ex-solution}
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")
ave_E <- c(3, 3, 6, 3, 3, 3)
# ערכו את הוקטור כאן:
ave_E[names=="Phoebe"]<-5
ave_E[names=="Ross"|names=="Chandler"]<-1
# הדפסה
ave_E

```

```{r ed_vec_ex-check}
grade_this({if (identical(.result, c(1, 1, 6, 3, 3, 5))) {pass("מעולה! ביצעת את כל העריכות הנדרשות")
}
  fail(" שם המשתתף. האם השתמשת בשם? אם כן יש לבדוק שהשתמשת בהשוואות הנכונות לביצוע העריכה והדפסתם את הוקטור המתוקן .")
})

```


## פונקציות בסיסיות
אז עכשיו שכבר אספנו לא מעט נתונים על החברים אפשר להתחיל להסתכל על התוצאות שלהם ברמת הקבוצה. 
בשיעור הקודם למדנו איך לבצע חיבור וחיסור למשל.   
באמצעות כלים אלה נוכל להתחיל לחשב את סכום ציוניהם של החברים בתכונה E כך:
```{r}
# נחזור לוקטור שיצרנו בתרגיל הקודם
ave_E <- c(1, 1, 6, 3, 3, 5)

# נחשב את הסכום הכולל באמצעות פעולת חיבור
ave_E_sum <- ave_E[1] + ave_E[2] + ave_E[3] + ave_E[4] + ave_E[5] + ave_E[6]

ave_E_sum
```

קצת מתיש לא?  
הדרך שהכרנו עד עכשיו תדרוש מאיתנו לבודד איבר איבר ולחבר בניהם באמצעות +. אך שפת התכנות יצרה עבורינו _פונקציות_ אשר יכולות לבצע פעולות שכאלה בצורה יעילה
למשל הפונקציה `sum()`

```{r}
# נחזור לוקטור שיצרנו קודם
ave_E <- c(1, 1, 6, 3, 3, 5)

# ועכשיו באמצעות הפונקציה sum()
ave_E_sum <- sum(ave_E)
ave_E_sum
```

התוצאה שהתקבלה כמובן זהה, אבל כמות העבודה שונה מהותית. 
קודם כל נתבונן בתבנית הסכמטית לעבודה עם פונקציה:
`output_variable <- function_name(argument_1, argument_2, ...)`  

ועכשיו לדוגמה נקביל את זה לדוגמה שראינו:
ave_E_sum <- sum(ave_E)

עכשיו נבודד כל רכיב בנפרד ונבין אותו לעומק:  
`output_variable` - זהו בעצם החלק במשוואה שאינו חובה ואם נשמיט אותו הקוד עדיין יעבוד, רק מה שיקרה במקום אכסון של התוצאה במשתנה הוא רק הדפסה שלה. שם המשתנה יכול להיות כל שם שנבחר, כמו כל משתנה אחר, בדוגמה שלנו הפלט הוא הסכום של הציונים הממוצעים ונקרא ave_E_sum.  

`function_name` - שם הפונקציה, לרוב מתכתבת עם הפעולה שנרצה לבצע. בדוגמה שלנו הפונקציה מבצעת סכימה ושמה הוא sum.  
כמה דברים שחשוב לשים אליהם לב:  
1. שם הפונקציה בדומה למשתנים נכתב ללא גרשיים  
2. שם הפונקציה צריך להיכתב במדוייק, למשל הפונקציה Sum איננה קיימת ובמידה ותנסו להשתמש בה תתקבל שגיאה.   
3. השימוש הנכון בפונקציה הוא - שם הפונקציה ואחריה סוגריים עגולים. בתוך הסוגריים נכניס את הקלט של הפונקציה (כל פונקציה והקלט שמתאים לה).  

`arguments` - הקלטים של הפונקציה. כל פונקציה מקבלת קלטים שונים, בהתאם לתפקודה.  בדוגמה שלנו הפונקציה קלטה וקטור של מספרים וחישבה את סכומו. לכן הקלט של הפונקציה הוא המספרים שנרצה לסכום. 

### מידע על פונקציות
אם תיכנסו לRstudio ותריצו את הקוד הבא בקונסולה:  
sum?
תגיעו לעמוד המידע של הפונקציה (מצד ימין למטה). בעמוד זה תוכלו לקרוא את תיאור הפונקציה ואיך להשתמש בה (Usage). עבור הפונקציה sum זה מה שמתואר:  
sum(..., na.rm = FALSE)  
מתחת לשימושים יש פירוט על השימוש בכל ארגומנט, ובדרך כלל יש גם דוגמאות שעוזרות להבין.

ועכשיו אתם מוכנים להתחיל לקרוא לבד. חפשו את הפונקציה round.  
שימו לב שבעמוד של הפונקציה מוצעות לכם עוד פונקציות שיכולות להיות שימושיות בתרחישים דומים. התעלמו מהן בנתיים וקראו רק את המידע המפורט על הפונקציה round. 

```{r descrip_question, echo = FALSE}
question("מה תפקידה של הפונקציה ?",
         answer("לספק איור גרפי של עיגולים",  message ="ניחוש פרוע! עכשיו פתחו את התיאור של הפונקציה ונסו שוב."),
         answer("לחשב את החזקה השניה של מספרים", message = " ניחשת? חזרו לתיאור הפונקציה וקראו שוב. דרך אגב יש פונקציה שמחשבת את הריבוע של מספרים והיא נקראית דווקא sqrt"),
         answer("הפונקציה מאתרת את המספר השכיח בוקטור", message = " ניחשת? חזרו לתיאור הפונקציה וקראו שוב"),
         answer("הפונקציה מעגלת מספרים ",correct =TRUE, message = "נכון, זהו התפקיד של הפונקציה"),
         allow_retry = TRUE
)
```


### ארגומנטים
הארגומנטים הם כל הקלטים שהפונקציה מקבלת. הם נכנסים בתוך הסוגריים העגולים `()` ומופרדים בינהם בפסיקים (במידה ויש יותר מארגומנט אחד). נמשיך עם הפונקציה round. אתם תצטרכו את דף המידע שלה גם לשאלה הבאה:  

```{r arg_question, echo = FALSE}
question("איזה ארגומנטים הפונקציה מקבלת (יש יותר מתשובה אחת נכונה) ?",
         answer("x - מספר או וקטור מספרי עליו תבוצע הפעולה", correct =TRUE, message ="נכון! זה בעצם המספר שנרצה לעגל."),
         answer("y - מספר האיברים בוקטור", message = " ניחשת? חזרו לתיאור הפונקציה וקראו שוב."),
         answer("digits - מספר הספרות",correct =TRUE, message = "נכון! כמות הספרות שלאחר הנקודה שנרצה שיהיה לתוצאה."),
         answer("type - סוג העיגול ", message = "ניחשת? חזרו לתיאור הפונקציה וקראו שוב"),
         allow_retry = TRUE
)
```

 אז הפונקציה round מקבלת שני ארגומנטים. הארגומנטים מאופיינים בשם ובסדר שלהם. כך שיש שתי דרכים בהן נוכל להכניס ערכים לארגומנטים השונים.  
 
```{r}
a = 7.94743982984289
b = 2
# לפי הסדר בו הארגומנטים מופיעים בתיאור
round(a, b)
# כלומר אם נהפוך את הסדר התוצאה תשתנה
round(b, a) 
# בעצם כאן הפונקציה מנסה לעגל מספר שהוא כבר עגול

## אופציה שניה
# לפי שם הארגומנט
round(x=a, digits=b)
# זה יעבוד גם אם נהפוך את הסדר
round(digits=b, x=a)
```

עוד פרט שחשוב לדעת הוא שהארגומנט digits הוא ארגומנט שלא חובה לפרט. למה? כיוון שהוא `ארגומנט בעל ברירת מחדל'. אתם יכולים לנסות להריץ בקונסולה שלכם את הקוד ללא הארגומנט digits ולראות מה קורה.  

```{r deafult_question, echo = FALSE}
question("אם לא נמלא ערך עבור ארגומנט זה מה תהיה התוצאה של הקוד למעלה ?",
         answer("8", correct =TRUE, message ="נכון! ערך ברירת המחדל הוא 0."),
         answer("7.947439", message = "לא נכון, ערך ברירת המחדל הוא 0, כלומר לעגל את המספר למספר השלם הקרוב."),
         answer("7.9", message = "לא נכון, ערך ברירת המחדל הוא 0, כלומר לעגל את המספר למספר השלם הקרוב ביותר."),
         answer("7", message = " לא נכון, ערך ברירת המחדל הוא 0, כלומר לעגל את המספר למספר השלם הקרוב ביותר. כיוון שהמספר המקורי יותר קרוב ל8 העיגול יתבצע כלפי מעלה ולא לפי הספרה הראשונה. "),
         allow_retry = TRUE
)
```

ועכשיו נחזור לפונקציה sum.
בדוגמה הקודמת לשימוש בפונקציה הכנסנו רק מספרים. הפונקציה לא מגבילה אותנו בכמות המספרים.  
היינו יכולים להכניס וקטור אחד, או מספר רב של מספרים מופרדים בפסיק, למשל:  
```{r}
vector <- c(1,2,3,4,5,6,7)

# נחשב סכום לוקטור
sum(vector)

# ועכשיו נכניס את כל המספרים מופרדים בפסיק
sum(1,2,3,4,5,6,7)

```
כלומר, התיאור של הארגומנט הראשון כ... מרמז לנו שאפשר להכניס מספר לא מוגבל של ארגומנטים כך.  
אבל אם תסתכלו מקרוב על תיאור הפונקציה תראו שיש ארגומנט נוסף `na.rm`.  
ארגומנט זה מיועד להכתיב לפונקציה את אופן ההתמודדות עם ערכים חסרים. אתם בטח שואלים מה הם ערכים חסרים?


### ערכים חסרים
במהלך איסוף נתונים ניתקל לא פעם במקרים בהם יהיו לנו נתונים חסרים. למשל אם פיבי איבדה סבלנות באמצע הניסוי ולא קיבלנו עבורה ערך של מוחנצות. לרוב מה שיקרה זה שהתא שאמור היה להכיל את הערך הזה יקבל ערך חסר, בשפת התכנות יש ערך מיוחד למקרים כאלה והוא נקרא `NaN` או `NA`. זהו ערך שיכול להחליף כל ערך אחר והוא שייך לקטגוריה חדשה של `ערכים חסרים` כלומר הוא לא מספר ולא טקסט.  

עכשיו נחזור לפונקציה ולארגומנט שמאפשר לנו לקבוע האם הפונקציה (סכום בדוגמה זאת, אך ארגומנט זה משותף לעוד פונקציות רבות שנלמד להכיר בהמשך) תתעלם מערכים חסרים או לא. אם נכניס לארגומנט na.rm את הערך TRUE היא תתעלם מהם ואם FALSE (או שלא נפרט כלום) היא תתחשב בהם שכן זה ערך ברירת המחדל,.  
מה שבעצם יקרה זה שלא ניתן לחשב סכום הכולל ערכים חסרים (שכן אין להם ערך מספרי) ולכן לא נקבל תוצאה אלא ערך חסר.

למשל:

```{r}
# נחליף את אחד הערכים בערך חסר
ave_E <- c(1, 1, 6, 3, 3, NaN)

# ועכשיו באמצעות הפונקציה sum()
ave_E_sum <- sum(ave_E)
ave_E_sum
# קיבלנו ערך חסר, שכן לא ניתן לחשב איתו סכום
# ועכשיו נוסיף את הארגומט כך שיסיר ערכים חסרים
ave_E_sum <- sum(ave_E, na.rm=TRUE)
ave_E_sum
```
עכשיו חושב לנו סכום ללא ערכים חסרים, התוכנה פשוט מתעלמת מהערך החסר ומחשבת את הסכום של 5 האיברים האחרים.  

עכשיו נכיר עוד כמה פונקציות נוספות:  
פונקציה נוספת שיכולה להיות שימושית היא הפונקציה `length()`. כמו שיכולתם לנחש, פונקציה זאת מחשבת את האורך של הוקטור, או יותר נכון את כמות האיברים שלו.
אם נריץ את שורת הקוד הבאה:  
length(ave_E_sum)  

```{r vector_fun_question, echo = FALSE}
question(" מה תהיה התוצאה?",
         answer("1", correct = TRUE, message ="נכוןת במשתנה בו חישבנו את הסכום יש ערך אחד בלבד"),
         answer("19", message = "זאת תהיה התוצאה של הפונקציה שמחשבת את סכום הוקטור ולא האורך שלו"),
         answer("FALSE", message = "זהו ערך לוגי, אורך הוקטור יהיה תמיד מספרי"),
         answer("6", message = "קרוב אבל לא בדיוק! הקוד למעלה מחשב את האורך של המשתנה שמכיל את הסכום של הוקטור המקורי (כלומר ערך בודד), עם זאת בוקטור המקורי של הנתונים שלנו יש 6 איברים."),
         allow_retry = TRUE
)
```

`תרגיל`  
עכשיו חשבו את ממוצע של החברים בתכונה E באמצעות הפונקציה sum והפונקציה length.  
תזכורת - ממוצע מחושב על ידי סכימה של כל האיברים חלקי מספר האיברים. לסיום הדפיסו את המשתנה אשר שומר את התוצאה. 
  
```{r mean_ex, exercise=TRUE, exercise.eval = FALSE}
ave_E <- c(1, 1, 6, 3, 3, 5)
# חשבו את הממוצע כאן:
total_ave_E <-
# הדפסת התוצאה
total_ave_E
```

```{r mean_ex-solution}
ave_E <- c(1, 1, 6, 3, 3, 5)

# ערכו את הוקטור כאן:
total_ave_E <- sum(ave_E)/length(ave_E)

# הדפסת התוצאה
total_ave_E
```

```{r mean_ex-check}
grade_this_code(correct = "כל הכבוד! חישבת את הממוצע נכון באמצעות הפונקציות!", incorrect = "הקוד שלך עוד לא מדוייק. האם השתמשת בפונקציות המתוארות? אפשר להגיע לתוצאה גם על ידי שימוש בפעולות אריתמתיות אך הפעם התבקשתם להשתמש בפונקציות. חשוב לשים לב לסוגריים של הפונקציות ולשימוש בתי הפונקציות נכונה כדי להגיע לממוצע.")

```

###
אמנם זה היה הרבה יותר קל מאשר החישוב באמצות אופרטורים, אבל יש דרך אפילו יותר קצרה. הפונקציה:
`mean()` 

```{r}
# ננסה לחזור על התרגיל
ave_E <- c(1, 1, 6, 3, 3, 5)
# נבצע את החישוב כך:
total_ave_E <- mean(ave_E)
total_ave_E
```


### פונקציות מספריות שכדאי להכיר
`var` - פונקציה המחשבת את השונות (מדד לסטיה מהממוצע בריבוע)  
`sd` - מחשב את סטיית התקן (מדד לסטיה הממוצעת מהממוצע)  
`min` - מחזיר לנו את הערך המינימלי בוקטור  
`max` - מחזיר לנו את הערך המקסימלי בוקטור  
`which.max` - מחזיר לנו את האינדקס של הערך המקסימלי בוקטור  
`which.min` - מחזיר לנו את האינדקס של הערך המינימלי בוקטור  
`unique` - מחזיר לנו וקטור חדש ובו רק הערכים הייחודיים שמופיעים בוקטור  
`sort` - פונקציה המחזירה לנו וקטור חדש, עם כל הערכים שקיימים בוקטור המקורי
רק בסדר עולה (אם מדובר במספרים) או לפי הא-ב אם מדובר במחרוזות.  
`rep` - הפונקציה מקבלת ערך ומספר חזרות ומחזירה וקטור החוזר על אותו הערך באורך הנבחר.  
`round` - פונקציה המקבלת שבר בודד או וקטור המכיל שברים ומעגלת אותו. ניתן להכניס לפונקציה את כמות הספרות שנרצה לשמור לאחר הנקודה העשרונית. למשל: 

אין צורך ללמוד את הרשימה בע"פ אבל במידת הצורך חזרו אליה.  
האם אלה כל הפונקציות שצריך לדעת? - לא, יהיו עוד רבות ומורכבות מאלה. זאת רק רשימה מאוד התחלתית.  
מחפשים פונקציה שעושה משהו ולא יודעים איזו פונקציה מתאימה? מותר ואף מומלץ לחפש באינטרנט. שאלו את גוגל או את הAI החביב עליכם. 
תמיד תוכלו לקרוא את תיאור הפונקציה כדי להבין איך להשתמש בה.

### פונקציות טקסט שכדאי להכיר

`nchar` - מחזירה את מספר התווים במחרוזת (כולל רווחים).  
`substr` - מחזירה חלק מהמחרוזת בין מיקום התו ההתחלתי ל־סופי.  
`tolower` - הופכת את כל האותיות במחרוזת לאותיות קטנות.  
`paste` - מחברת כמה מחרוזות יחד, עם מפריד שניתן להגדיר (ברירת מחדל רווח). הפונקציה `paste0` מבצעת את אותה פעולה אך מחברת מחרוזות ללא רווחים או מפרידים.  
`grep` - מחפש מחרוזת תואמת בתוך וקטור טקסטים, ומחזיר את המיקומים (אינדקסים).  
`gsub` - מחפש מחרוזת תואמת בתוך טקסט ומחליף אותה בטקסט אחר (כל המופעים). 
בהרבה מהפונקציות שהכרנו כאן אפשר להשתמש בכמה דרכים, דרך ערכים בודדים וגם דרך וקטורים. למשל:  

```{r}
# נחבר מחרוזות באמצעות ערכים
paste("a", "b", "c", sep="*")

# ועכשיו דרך וקטור
char_vec <- c("a", "b", "c")
paste(char_vec, sep="*")

```

`תרגיל`  
בתיבת הקוד למטה נתונות לכם כמה מילים המאוכסנות בתוך משתנים. צרו משתנה שנקרא full_text ומכיל משפט שלם המורכב מכל המילים שנתונות לכם לפי הסדר.  כל מילה יכולה לחזור פעם אחת בלבד ובטקסט המלא כל מילה צריכה להיות מופרדת מזאת שאחריה ברווח.  

```{r text_fun_ex, exercise=TRUE, exercise.eval = FALSE}
word_1 <- "I'll"
word_2 <- "be"
word_3 <- "there"
word_4 <- "for"
word_5 <- "you"
#צרו את הטקסט כאן:
full_text <-
```

```{r text_fun_ex-solution}
word_1 <- "I'll"
word_2 <- "be"
word_3 <- "there"
word_4 <- "for"
word_5 <- "you"
#צרו את הטקסט כאן:
full_text <- paste(word_1, word_2, word_3, word_4, word_5)

```

```{r text_fun_ex-check}
grade_this({if (.result=="I'll be there for you") {pass("מעולה! יצא לכם משפט מצויין")
}
  fail(" הקוד שלכם עוד לא שם. האם כללתם רווחים? האם חיברתם את כל המילים לפי הסדר?.")
})
```


השתמשו בתיבת הטקסט הבאה כדי לענות על השאלות הבאות. צרו גם פה את המשתנה full_text באותו האופן שיצרתם אותו בשאלה הקודמת וענו על השאלות הבאות לגביו:  
```{r text_fun_play_ex, exercise=TRUE, exercise.eval = FALSE}
word_1 <- "I'll"
word_2 <- "be"
word_3 <- "there"
word_4 <- "for"
word_5 <- "you"
full_text <-
```

```{r text_fun_q, echo = FALSE}

question_text(
  "<div style='direction: rtl;'>מה אורך הטקסט המלא (כמה תווים הוא מכיל)?</div>",
  answer("21", correct = TRUE),
  allow_retry = TRUE,
  
           
  correct="נכון מאוד!", 
  incorrect = "נסו שוב"
)

```

### סוגי משתנים למתקדמים
עכשיו, נכיר עוד סוג אחד של משתנה שלא הכרנו בשיעור הקודם `הפקטור - factor`.
הפקטור הוא וקטור שמזכיר קצת וקטור לוגי, מהבחינה שהוא יכול לקבל רק כמות מסוימת ומוגדרת של ערכים, אך הוא לא מוגבל לנכון ולא נכון אלא יכול לקבל כל סוג ערכים שנרצה.  
למשל הוקטור שהכיל את המגדר של החברים, הוא וקטור עם ערכים שאנחנו הגדרנו אבל הוא יכול לקבל רק סט מסוים של ערכים (גבר או אישה).  
כעת נראה דוגמה להגדרה של פקטור:

```{r}
# כדי לסווג משתנה כפקטור נשתמש בפונקציה 
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))

# הפונקציה הבאה תוכל להראות לנו איזה ערכים וקטור כזה יכול לקבל:
levels(gender)

```

בדוגמה למעלה נעשה שימוש בשתי פונקציות:
`as.factor` - פונקציה שמקבלת וקטור מכל סוג והופכת אותו לפקטור
`levels` - פונקציה שמקבלת וקטור שהוגדר כפקטור ומציגה לנו את הרמות השונות שהוגדרו תחת אותו פקטור. פונקציה זאת תשמש אותנו כדי לבדוק מה הרמות שקיימות בפקטור וגם כדי לערוך אותו.

שימו לב! לאחר ההגדרה, הוקטור מוגבל ולא ניתן להוסיף לו ערכים שלא היו קיימים בוקטור המקורי.   
למשל, פיבי ביקשה שלא יציינו עבורה את משתנה זה. בכל מחקר צריך לאפשר למשתתפים להרגיש בנוח. לכן נרצה להוסיף רמה שלישית: Unknown  או בקיצור U

```{r}
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))

# ננסה להכניס את הערך U
gender[6] <- "U"

```

התוכנה מעלה לנו שגיאה. שכן היא לא מכירה את הערך "U" כרמה בפקטור שלנו.   
מה שקרה הוא שהערך הוחלף אבל בערך חסר ולא ברמה החדשה שרצינו לייצר. לכן כדי לעשות זאת נכון נצטרך קודם כל להוסיף את הרמה "U".

```{r}
# נערוך את הוקטור שמגדיר את רמות הפקטור
levels(gender) <- c("M", "F", "U")

# ננסה שוב
gender[6] <- "U"

# ועכשיו נציג
gender
```

אנחנו גם גמישים לשנות את הקידוד בקלות אם הוא לא נוח ועדיף היה להשתמש במילים שלמות.   
אנחנו יכולים גם לערוך את השמות של הרמות באותה הדרך שהוספנו רמה.  

```{r}
levels(gender) <- c("Female", "Male", "Unknown")
# זה יגרום לשינוי מיידי של הפקטור שלנו
# דרך מאוד יעילה לערוך שינויים!
gender
```

בנוסף לפונקציה `as.factor()` המגדירה פקטור, יש עוד שני סוג וקטורים שלפעמים נרצה לעבור בינהם. לכן כדאי להכיר את הפונקציות:

`as.numeric()` - תהפוך את הפורמט של הוקטור כולו למספרי. התוצאה תהיה int או float בהתאם למה שקיים בוקטור. פונקציה זאת שימושית במיוחד במקרים שיש ספרות בפורמט של טקסט ורוצים לבצע עליו פעולות מספריות.   

`as.character()` - תהפוך את הפורמט כולו לטקסט (character הן בעצם אותיות או תוים, אבני הבנין של המחרוזות). פונקציה זאת שימושית אם רוצים להשתמש במספרים בפורמט טקסט. 

ואחרונה חביבה:
`class()` - פונקציה שתדפיס לנו לאיזה סוג משתייך הוקטור. הכניסו את שם המשתנה בסוגריים והפונקציה תדפיס לכם את התשובה.


## תרגיל מסכם
```{r}
# נתונים דמוגרפיים
names <- c("Ross", "Chandler", "Joey", "Rachel", "Monica", "Phoebe")  
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))  
employment <- c("yes", "yes", "no", "yes", "no", "no")  
income <- c(75, 100, 20, 50, 80, NaN)  

#תשובות לשאלונים:  
ave_E <- c(1, 1, 6, 3, 3, 5)  
ave_C <- c(6, 4, 2, 3, 7, 1)  
ave_A <- c(4, 4, 5, 7, 3, 6)  
ave_N <- c(6, 7, 1, 3, 6, 2)  
ave_O <- c(2, 3, 6, 3, 1, 7)  

``` 

שימו לב, זה זמן טוב להתחיל לתרגל את הרעיון של סביבת עבודה. בתרגילים הבאים כבר נתחיל לפנות אתכם החוצה מן הלומדה אל התוכנה עצמה. אבל לפני שנעשה זאת נכיר את המושג של "סביבת עבודה". כלומר, כל פעם שאנחנו מריצים שורת קוד שכוללת הגדרה של משתנים המשתנים שהגדרנו יהיו קיימים לנו ונגישים לנו בסביבה ואנחנו יכולים להשתמש בהם, על ידי קריאה בשמם, מבלי להגדיר אותם מחדש. בתרגילים מטה, כל תיבת פתרון של שאלה מהווה סביבת עבודה נפרדת. לכן עליכם להבין איזה משתנים תצטרכו לפתרון השאלה והעתיקו אותם.
  
`שאלה 1`  
לאחר ההשתתפות במחקר החברים ביקשו לקבל חוות דעת על האישיות שלהם. 
הם היו רוצים לדעת מה היא תכונת האישיות הכי דומיננטית בקבוצה שלהם.  
כלומר, עליכם לחשב את הממוצע של קבוצת החברים עבור כל תכונת אישיות ולהדפיס את שם התכונה (להזכירכם, אנו משתמשים באות אנגלית גדולה כשמות לתכונות השונות) בעלת הערך הגבוה ביותר.  
רמז: הפונקציה שעוזרת לנו למצוא את האינדקס של הערך הגבוה ביותר בוקטור היא:
`which.max`

```{r final_ex_1, exercise=TRUE, exercise.eval = FALSE}
# נתונים:

# פתרון:

# הדפסת התשובה הסופית:

```

```{r final_ex_1-solution}
# נתונים:
ave_E <- c(1, 1, 6, 3, 3, 5)
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_A <- c(4, 4, 5, 7, 3, 6)
ave_N <- c(6, 7, 1, 3, 6, 2)
ave_O <- c(2, 3, 6, 3, 1, 7)
# פתרון:
dim_name <- c("E", "C", "A", "N", "O")
dim_ave_total <- c(mean(ave_E), mean(ave_C), mean(ave_A), mean(ave_N), mean(ave_O))
# הדפסת התשובה הסופית:
dim_name[which.max(dim_ave_total)]
```
<div id="final_ex_1-hint">
**Hint:** צריכים עזרה?  
נעבור על השלבים לפתרון אחד אחד.  

מה אנחנו מחפשים?
אנחנו רוצים לדעת איזו תכונת אישיות היא הדומיננטית ביותר בקבוצה – כלומר איזו תכונה קיבלה את הממוצע הגבוה ביותר.

אילו נתונים דרושים לנו?
נצטרך את כל הווקטורים שמכילים את תוצאות השאלות עבור חמש התכונות (O, C, E, A, N).

יצירת וקטור ממוצעים
צרו וקטור חדש (למשל ave_score) שבו יהיו 5 ערכים – כל ערך הוא הממוצע של תכונה אחת.

יצירת וקטור שמות
צרו וקטור נוסף (למשל names) שבו יהיו חמש אותיות – O, C, E, A, N.
שימו לב: זה צריך להיות וקטור טקסט, כלומר הקפידו על שימוש ב"".

התאמה בין הווקטורים
חשוב מאוד: סדר האיברים בשני הווקטורים חייב להיות זהה. אם הממוצע הראשון ב־ave_score שייך ל־O, אז האות הראשונה ב־names צריכה להיות "O".

מציאת הערך הגדול ביותר
השתמשו בפונקציה which.max על וקטור הממוצעים (ave_score) כדי למצוא את האינדקס של התכונה עם הערך הגבוה ביותר.

קבלת שם התכונה
בעזרת האינדקס שחזר מ־which.max, גשו לאינדקס של האות המתאימה מווקטור names והדפיסו אותה.
</div>
```{r final_ex_1-check}
grade_this({if (identical(.result, "A")) {
    pass("מצויין! התכונה בעלת הציון הגבוה ביותר היא A. בונוס - הידעת שאם תשתמשו בפונקציה max על מחרוזות היא תחזיר את הערך הגבוה ביותר לפי האלף-בית? ")
  }
  fail("זאת לא התשובה הנכונה.. נסו שוב!")
})

```

`שאלה 2`   
פנו אליכם מהמחלקה למנהל עסקים וייעוץ עסקי. הם כרגע עורכים מחקר על הקשר שבין מוסר עבודה לנטיה לפתח הפרעות נפשיות (נוירוטיות) בקרב מובטלים.  
  במחווה של רצון טוב הסכמתם לעזור להם ולשלוח להם נתונים אנונימים של משתתפי המחקר. הם ביקשו לקבל וקטור הנקרא C_N_ratio של משתתפים מובטלים אשר מכיל את היחס בין נוירוטיות (N) למוסר עבודה (C). כלומר, על הוקטור להכיל רק את נתוניהם של המשתתפים המובטלים ועבור כל משתתף הם מבקשים לקבל את הציון של אותו משתתף בתכונה N חלקי הציון של אותו משתתף בתכונה C.
  עגלו את התוצאות לשתי ספרות אחרי הנקודה העשרונית.  
  

```{r final_ex_2, exercise=TRUE, exercise.eval = FALSE}
# נתונים:

# ערכו את הנתונים כאן:

# פתרון:

# הדפסת התשובה הסופית:

```

```{r final_ex_2-solution}
# נתונים:
employment <- c("yes", "yes", "no", "yes", "no", "no")
ave_C <- c(6, 4, 2, 3, 7, 1)
ave_N <- c(6, 7, 1, 3, 6, 2)
# ערכו את הנתונים כאן
ave_C1=ave_C[employment=="no"]
ave_N1=ave_N[employment=="no"]

# פתרון:
C_N_ratio=round(ave_N1/ave_C1,2)

# הדפסת התשובה הסופית:
c_N_ratio
```

<div id="final_ex_2-hint">
**Hint:** צריכים עזרה?  
נעבור על השלבים לפתרון אחד אחד 
מה אנחנו מחפשים?
עלינו ליצור וקטור חדש בשם C_N_ratio שמכיל עבור כל משתתף מובטל את היחס בין הציון שלו בנוירוטיות (N) לבין הציון שלו במוסר עבודה (C), כשהתוצאות מעוגלות לשתי ספרות אחרי הנקודה.

אילו נתונים דרושים לנו?
נצטרך את הציונים בתכונות N ו־C, וגם את המידע על מצב התעסוקה של המשתתפים כדי לזהות מי מהם מובטלים.

סינון המשתתפים
ניצור וקטור המכיל רק את האינדקסים של המשתתפים שאינם מועסקים (כלומר מובטלים) באמצעות השוואה עם הוקטור של מצב התעסוקה. 

חישוב היחס
בשלב זה ניצור  את הווקטור החדש בשם C_N_ratio.
הווקטור יכיל את החילוק של ציון N בציון Cרק עבור האינדקסים של המשתתפים המובטלים שזיהינו בשלב הקודם.
מיד לאחר מכן נעגל את הווקטור C_N_ratio לשתי ספרות אחרי הנקודה כך שהתוצאה תהיה מדויקת וברורה. לשם כך נוכל להשתמש בround.  
</div>

```{r final_ex_2-check}
grade_this({if (identical(.result, c(0.50, 0.86, 2.00))) {
    pass("מעולה! המחלקה למנהל עסקים מודה לכם!")
  }
  fail("זאת לא התשובה הנכונה.. נסו שוב!")
})
```

`שאלה 3`  
המחלקה לכלכלה עורכת מחקר על הקשר בין מוסר עבודה לבין הפליה מגדרית בשכר.
כחלק מהמחקר הם ביקשו לבדוק האם בנתונים שלנו קיימים הפרשי שכר שעשויים להעיד על הפליה מגדרית בקרב עובדים עם מוסר עבודה גבוה (מעל 3).

חשבו את ההפרש בין השכר הממוצע של נשים לבין השכר הממוצע של גברים בקבוצת העובדים עם מוסר עבודה גבוה.  
שימו לב, כדי לזהות את האינדקסים הנכונים לכל קבוצה תצטרכו להשתמש בהשוואות יחד עם פעולה לוגית (שתזהה את אלה בעלי מוסר עבודה גבוה וגם ממגדר מסוים.


```{r final_ex_3, exercise=TRUE, exercise.eval = FALSE}
# נתונים:

# פתרון:

# הדפסת התשובה הסופית:

```

<div id="final_ex_3-hint">
**Hint:** צריכים עזרה?  
 הנתונים
ראשית, בדקו אילו נתונים אתם צריכים:  השאלה נוגעת במשתנים של מגדר (gender), שכר (income) ומוסר עבודה (ave_C). 

סינון לפי מוסר עבודה גבוה
כדי להשוות בין נשים וגברים עם מוסר עבודה גבוה ניצור שני וקטורים (אחד לנשים ואחד לגברים) אשר מכילים את המשכורות של המשתתפים הרלוונטיים.
שימו לב: יש להסתכל על המוסכמה של הערך הגבוה – כאן נחשב "גבוה" כציון מעל 3. אתם תידרשו לבצע שתי השוואות (של C ושל המגדר) ולוודא ששתיהן מתקיימות (כלומר תנאי של וגם).

חישוב ממוצעים
עכשיו יש לחשב את ממוצע השכר לכל קבוצה (נשים עם מוסר עבודה גבוה, גברים עם מוסר עבודה גבוה).
כדאי להשתמש בפרמטר שמאפשר להתעלם מערכים חסרים (na.rm=TRUE) .

חישוב ההפרש
לבסוף, הפחיתו את ממוצע השכר של הגברים מממוצע השכר של הנשים עם מוסר עבודה גבוה. התוצאה היא ההפרש הממוצע (high_c_diff).
זהו הערך שממחיש את הפער המגדרי בשכר בקרב קבוצת העובדים עם מוסר עבודה גבוה.

</div>
```{r final_ex_3-solution}
# נתונים
gender <- as.factor(c("M", "M", "M", "F", "F", "F"))  
income <- c(75, 100, 20, 50, 80, NA)  
ave_C <- c(6, 4, 2, 3, 7, 1)

# חישוב הפרש ממוצע שכר בקרב עובדים עם מוסר עבודה גבוה
# שכר נשים עם C>3
f_high <- income[gender == "F" & ave_C > 3]  
# שכר גברים עם C>3
m_high <- income[gender == "M" & ave_C > 3]  
high_c_diff <- mean(f_high, na.rm = TRUE) - mean(m_high, na.rm = TRUE)

# הדפסת התשובה הסופית:
high_c_diff
```

```{r final_ex_3-check}
grade_this({if (identical(.result, -7.5)) {
    pass("יפה מאוד! קיבלנו שאצל נשים בעלות מוסר עבודה גבוהה יש אפילו פער שלילי בשכר (כלומר הן מרוויחות 7.5 אלף דולר פחות בשנה). החוקרים מהמחלקה לכלכלה בטוח יתעניינו בנתונים האלה!")
  }
  fail("זאת לא התשובה הנכונה.. נסו שוב!")
})

```

## משוב

בחלק זה נבקש את המשוב שלכם על הלומדה. אנא ענו בכנות וביסודיות, על מנת שנוכל להשתפר. התשובות ישמרו בצורה אנונימית ולא ישפיעו על בדיקת התרגיל עצמה.  
שימו לב: ברוב השאלות אין אפשרות לשנות את התגובה לאחר לחיצה על כפתור ההגשה.

```{r survey_q1, echo = FALSE}
question("מה הייתה רמת הקושי של הלומדה עבורך? יש להתייחס לכמה הבנת את החומר ולרמת הקושי של התרגול עבורך. ",
         type="single",
         answer("קלה"        ,correct=TRUE,  message = "תגובתך: קלה"),
         answer("בינונית"    ,correct=TRUE,  message = "תגובתך: בינונית"),
         answer("מאתגרת"     ,correct=TRUE,  message = "תגובתך: מאתגרת"),
         answer("קשה"        ,correct=TRUE,  message = "תגובתך: קשה"),
         answer("קשה מאוד"   ,correct=TRUE,  message = "תגובתך: קשה מאוד"),
         correct = "",
         incorrect = "",
         allow_retry = TRUE
)
```

```{r survey_q2, echo = FALSE}
question("עד כמה החומר הנלמד ביחידה הועבר בצורה ברורה לדעתך?",
         type="single",
         answer("במידה רבה"      , correct=TRUE,  message = "תגובתך: במידה רבה"),
         answer("במידה סבירה" ,    correct=TRUE,  message = "תגובתך: במידה סבירה"),
         answer("באופן חלקי"  ,    correct=TRUE,  message = "תגובתך: באופן חלקי"),
         answer("במידה מעטה"  ,correct=TRUE,  message = "תגובתך: במידה מעטה"),
         answer("במידה מעטה מאוד",correct=TRUE,  message = "תגובתך: במידה מעטה מאוד"),
         correct = "",
         incorrect = "",
         allow_retry = TRUE)
```

```{r survey_q3, echo = FALSE}
question("כמה זמן לקח לך לפתור את הלומדה בערך?",
         type="single",
         answer("פחות משעה"      , correct=TRUE,  message = "תגובתך: פחות משעה"),
         answer("שעה" ,    correct=TRUE,  message = "תגובתך: שעה"),
         answer("שעתיים"  ,    correct=TRUE,  message = "תגובתך: שעתיים "),
         answer("שלוש שעות"  ,correct=TRUE,  message = "תגובתך:  שלוש שעות"),
         answer("ארבע שעות ומעלה",correct=TRUE,  message = "תגובתך:  ארבע שעות ומעלה "),
         correct = "",
         incorrect = "",
         allow_retry = TRUE)
```

```{r survey_q4, echo = FALSE}
question(" אילו נושאים בלומדה היו קשים במיוחד עבורך?",type="learnr_checkbox",
         answer("וקטורים", correct=TRUE),
         answer("אינדקסים", correct=TRUE),
         answer("פונקציות מבוא", correct=TRUE),
         answer("ארגומנטים", correct=TRUE),
         answer("ערכים חסרים", correct=TRUE),
         answer("פקטור", correct=TRUE),
         correct = "תשובתך התקבלה. תודה על הפירוט",
         try_again = "תשובתך התקבלה. תודה על הפירוט",
         incorrect = "תשובתך התקבלה. תודה על הפירוט",
         allow_retry = TRUE
)
```

```{r survey_q5, echo = FALSE}
  question_text(
    " מצאת טעות? ספר/י לנו עליה (יש להקפיד ולציין את שם הפרק)",
    incorrect = "תשובתך התקבלה!",
    correct = "תשובתך התקבלה!",
    answer(text = "asd",message="DFGDF"),
    answer(text = "",correct = TRUE),
    rows = 10,
    trim = FALSE
  )
```

```{r survey_q6, echo = FALSE}
  question_text(
    "יש לך עוד משהו לספר לנו? נשמח לשמוע משוב מפורט, הצעות כלליות או ספציפיות לפרק מסוים לגבי יחידה זאת.",
    incorrect = "תשובתך התקבלה",
    correct = "תשובתך התקבלה",
    answer(text = "asd",message="DFGDF"),
    answer(text = "",correct = TRUE),
    rows = 10,
    trim = FALSE
  )
```


## הגשת התרגיל
  סיימת? מעולה! עכשיו הגיע הזמן להגיש את התרגיל.  
  יש ללחוץ על הכפתור:  Generate  
  להעתיק את הטקסט שמופיע בחלון למטה ולהגישו במודל  
  בהצלחה!

```{r context="server"}
learnrhash::encoder_logic()
```

```{r encode, echo=FALSE}
learnrhash::encoder_ui()
```


הדביקו את קוד הhash בתוך הגרשיים בפונקצייה הבאה כדי לוודא שעניתם על כל השאלות והתרגילים בלומדה.

```{r hash_check,  exercise = TRUE, exercise.eval = FALSE}

check_hash_code("")

```



